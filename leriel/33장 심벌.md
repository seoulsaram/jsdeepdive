---

### 33.1 심벌(Symbol)이란?

자바스크립트는 6가지 원시 타입(문자열, 숫자, 불리언, `undefined`, `null`, 객체) 외에 ES6에서 7번째 데이터 타입인 심벌(Symbol)을 도입했습니다. 심벌은 **변경 불가능한 원시 타입의 값**으로, 주로 **이름의 충돌 위험이 없는 유일한 프로퍼티 키**를 만들기 위해 사용됩니다.

심벌 값은 다른 어떤 값과도 중복되지 않는 **유일무이한 값**입니다. 따라서 기존에 작성된 코드에 영향을 주지 않고 새로운 프로퍼티를 추가할 때 유용하게 활용될 수 있습니다.

### 33.2 심벌 값의 생성

### 33.2.1 Symbol 함수

심벌 값은 `Symbol` 함수를 호출하여 생성합니다. 이때 `new` 연산자와 함께 호출하지 않습니다.

```jsx
// 심벌 값 생성
const mySymbol = Symbol();
console.log(typeof mySymbol); // symbol

// 심벌은 유일무이한 값이다.
const mySymbol1 = Symbol('myDescription');
const mySymbol2 = Symbol('myDescription');
console.log(mySymbol1 === mySymbol2); // false
```

`Symbol` 함수는 선택적으로 문자열을 인수로 전달받을 수 있습니다. 이 문자열은 심벌 값에 대한 설명(description) 역할을 하며, 디버깅 용도로만 사용될 뿐 심벌 값 자체에는 어떤 영향도 주지 않습니다.

### 33.2.2 Symbol.for / Symbol.keyFor 메서드

`Symbol.for()` 메서드는 인수로 전달받은 문자열을 키로 사용하여 심벌 레지스트리(Symbol Registry)에 저장된 심벌 값 중 일치하는 심벌 값을 검색합니다.

- **존재하는 경우:** 해당 심벌 값을 반환합니다.
- **존재하지 않는 경우:** 새로운 심벌 값을 생성하여 심벌 레지스트리에 저장한 후 반환합니다.

```jsx
const s1 = Symbol.for('myKey'); // 새로운 심벌 생성 및 레지스트리 저장
const s2 = Symbol.for('myKey'); // 기존 심벌 반환

console.log(s1 === s2); // true
```

`Symbol.keyFor()` 메서드는 심벌 레지스트리에 저장된 심벌 값의 키(설명 문자열)를 검색하여 반환합니다. 심벌 레지스트리에 등록되지 않은 심벌은 검색할 수 없습니다.

```jsx
const s3 = Symbol.for('anotherKey');
console.log(Symbol.keyFor(s3)); // anotherKey

const s4 = Symbol('yetAnotherKey'); // Symbol() 함수로 생성된 심벌은 레지스트리에 등록되지 않음
console.log(Symbol.keyFor(s4)); // undefined
```

---

### 33.3 심벌과 상수

심벌은 값이 중복될 염려가 없으므로 **상수 값으로 사용**하기에 적합합니다. 특히, 열거형(enum)을 구현할 때 문자열 상수가 가질 수 있는 충돌 위험을 제거할 수 있습니다.

```jsx
// 기존 문자열 상수의 문제점
const Direction = {
    UP: 'UP',
    DOWN: 'DOWN',
    LEFT: 'LEFT',
    RIGHT: 'RIGHT'
};

// 다른 모듈에서 동일한 문자열 상수를 정의할 경우 충돌 위험
// const Direction = { UP: 'UP', ... };

// 심벌을 이용한 열거형
const DirectionSymbol = {
    UP: Symbol('up'),
    DOWN: Symbol('down'),
    LEFT: Symbol('left'),
    RIGHT: Symbol('right')
};

function move(direction) {
    switch (direction) {
        case DirectionSymbol.UP:
            console.log('위로 이동!');
            break;
        case DirectionSymbol.DOWN:
            console.log('아래로 이동!');
            break;
        default:
            console.log('알 수 없는 방향');
    }
}

move(DirectionSymbol.UP); // 위로 이동!
move(Symbol('up')); // 알 수 없는 방향 (Symbol('up')은 DirectionSymbol.UP과 다른 심벌)
```

---

### 33.4 심벌과 프로퍼티 키

심벌은 객체의 프로퍼티 키로 사용될 수 있습니다. 심벌을 프로퍼티 키로 사용하면 다른 프로퍼티 키와 **이름이 충돌할 위험이 없습니다.**

```jsx
const id = Symbol('id');

const user = {
    name: 'Alice',
    [id]: 123 // 심벌을 프로퍼티 키로 사용
};

console.log(user); // { name: 'Alice', [Symbol(id)]: 123 }
console.log(user[id]); // 123
```

---

### 33.5 심벌과 프로퍼티 은닉

심벌을 프로퍼티 키로 사용하면 해당 프로퍼티는 `for...in` 문이나 `Object.keys()`, `Object.getOwnPropertyNames()` 메서드로 열거되지 않습니다. 이 특성을 이용하여 외부에 노출하고 싶지 않은 프로퍼티를 "은닉"할 수 있습니다.

```jsx
const secret = Symbol('secret');

const obj = {
    name: 'Bob',
    [secret]: 'This is a secret message.'
};

for (const key in obj) {
    console.log(key); // name
}

console.log(Object.keys(obj)); // ['name']
console.log(Object.getOwnPropertyNames(obj)); // ['name']

// 심벌 프로퍼티는 Object.getOwnPropertySymbols()로만 가져올 수 있다.
console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(secret)]
console.log(obj[Object.getOwnPropertySymbols(obj)[0]]); // This is a secret message.
```

---

### 33.6 심벌과 표준 빌트인 객체 확장

심벌은 기존 표준 빌트인 객체에 **메서드를 추가할 때 기존 프로퍼티와의 충돌을 피할 수 있게 해줍니다.** 예를 들어, `Array.prototype`에 새로운 메서드를 추가할 때 심벌을 사용하면, 만약 나중에 ECMA스크립트 표준에서 동일한 이름의 메서드가 추가되더라도 충돌 없이 안전하게 확장할 수 있습니다.

```jsx
// Array.prototype에 사용자 정의 메서드 추가 (심벌 사용)
Array.prototype[Symbol('sum')] = function() {
    return this.reduce((acc, cur) => acc + cur, 0);
};

const arr = [1, 2, 3];
console.log(arr[Symbol('sum')]()); // undefined (다른 심벌)

// 올바른 사용법: 동일한 심벌을 참조해야 함
const mySumSymbol = Symbol('sum');
Array.prototype[mySumSymbol] = function() {
    return this.reduce((acc, cur) => acc + cur, 0);
};

console.log(arr[mySumSymbol]()); // 6
```

이 방식은 일반적인 확장보다는 잘 알려진 심벌(Well-known Symbol)의 목적에 더 가깝습니다. 표준 빌트인 객체 확장은 일반적으로 권장되지 않으며, 필요하다면 믹스인 패턴 등을 고려하는 것이 좋습니다.

---

### 33.7 Well-known Symbol

자바스크립트 자체에 내장된 심벌들을 **Well-known Symbol**이라고 합니다. 이 심벌들은 특정 빌트인 메서드의 동작을 오버라이드하거나, 자바스크립트 내부 동작을 정의하는 데 사용됩니다.

몇 가지 예시:

- **`Symbol.iterator`**: `for...of` 루프가 동작하는 방식을 정의합니다. 객체가 이 심벌을 키로 갖는 메서드를 구현하면 이터러블이 됩니다.
- **`Symbol.asyncIterator`**: 비동기 이터레이터의 동작을 정의합니다.
- **`Symbol.hasInstance`**: `instanceof` 연산자의 동작 방식을 정의합니다.
- **`Symbol.toStringTag`**: `Object.prototype.toString()` 메서드의 반환 값을 정의합니다.

```jsx
// Symbol.iterator 예시
const myIterable = {
    [Symbol.iterator]() {
        let count = 0;
        return {
            next() {
                if (count < 3) {
                    return { value: count++, done: false };
                }
                return { value: undefined, done: true };
            }
        };
    }
};

for (const item of myIterable) {
    console.log(item); // 0, 1, 2
}

// Symbol.toStringTag 예시
class MyClass {
    get [Symbol.toStringTag]() {
        return 'MyCustomClass';
    }
}

const instance = new MyClass();
console.log(Object.prototype.toString.call(instance)); // [object MyCustomClass] 
  
```

---