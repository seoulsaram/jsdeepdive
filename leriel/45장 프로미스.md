---

## 1. 프로미스 핵심 개념 정리

### 1-1. 프로미스란?

- **비동기 작업의 결과를 담는 ‘상자’**
- 세 가지 상태:
    - `pending` (대기)
    - `fulfilled` (성공, `value`를 가짐)
    - `rejected` (실패, `reason`을 가짐)

### 가장 기본적인 예

```tsx
const p = new Promise<number>((resolve, reject) => {
  setTimeout(() => {
    const n = Math.random();
    if (n > 0.5) {
      resolve(n);
    } else {
      reject(new Error("0.5 이하입니다"));
    }
  }, 1000);
});

p.then((value) => {
  console.log("성공:", value);
})
  .catch((err) => {
    console.error("실패:", err.message);
  })
  .finally(() => {
    console.log("항상 실행");
  });

```

---

### 1-2. then / catch / finally 체이닝

### 체이닝 기본 형태

```tsx
function fetchUser(id: number): Promise<{ id: number; name: string }> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id, name: "Leriel" });
    }, 500);
  });
}

fetchUser(1)
  .then((user) => {
    console.log("user:", user);
    return user.name.toUpperCase();
  })
  .then((upperName) => {
    console.log("upperName:", upperName);
  })
  .catch((err) => {
    console.error("에러 발생:", err);
  });

```

- `then`은 항상 **새로운 프로미스**를 반환한다는 점이 중요.
- `catch`도 마찬가지로 새 프로미스를 반환 → 이후 체이닝 가능.

---

### 1-3. 프로미스의 에러 전파

```tsx
Promise.resolve(1)
  .then((v) => {
    console.log("1단계:", v);
    throw new Error("여기서 터졌어요");
  })
  .then((v) => {
    // 실행되지 않음
    console.log("2단계:", v);
  })
  .catch((err) => {
    console.error("catch에서 잡음:", err.message);
    return 42; // 복구 후 값 반환
  })
  .then((v) => {
    console.log("복구 후 값:", v); // 42
  });

```

- `then` 내부에서 에러가 throw되면 **자동으로 rejected 상태**로 바뀌고 `catch`로 전파.

---

### 1-4. async / await와 프로미스

`async` 함수는 항상 프로미스를 반환합니다.

```tsx
async function fetchNumber(): Promise<number> {
  return 123; // 사실은 Promise.resolve(123)
}

async function main() {
  try {
    const n = await fetchNumber();
    console.log("n:", n);
  } catch (err) {
    console.error("에러:", err);
  }
}

```

### async/await로 체이닝 리팩터링

```tsx
function delay(ms: number) {
  return new Promise<void>((resolve) => setTimeout(resolve, ms));
}

async function getUserNameUpper(id: number): Promise<string> {
  await delay(500);
  const user = { id, name: "Leriel" };

  if (!user) {
    throw new Error("User not found");
  }

  return user.name.toUpperCase();
}

(async () => {
  try {
    const name = await getUserNameUpper(1);
    console.log("NAME:", name);
  } catch (err) {
    console.error("에러:", (err as Error).message);
  }
})();

```

---

### 1-5. 병렬 실행: Promise.all / Promise.allSettled / Promise.race

### Promise.all

```tsx
const p1 = delay(500).then(() => "A");
const p2 = delay(1000).then(() => "B");

Promise.all([p1, p2])
  .then(([a, b]) => {
    console.log(a, b); // "A", "B" (최대 오래 걸린 p2까지 기다림)
    Promise.reject()
  })
  .catch((err) => {
    console.error("하나라도 실패하면 여기로:", err);
  });
  
  

```

### Promise.allSettled

```tsx
const p3 = Promise.resolve("OK");
const p4 = Promise.reject(new Error("NO"));

Promise.allSettled([p3, p4]).then((results) => {
  for (const r of results) {
    if (r.status === "fulfilled") {
      console.log("성공:", r.value);
    } else {
      console.log("실패:", r.reason);
    }
  }
});
```

---

### 1-6. 프로미스의 한계 (Effect TS로 넘어가기 위한 포인트)

코드로 보는 문제점들:

1. **에러 타입이 불명확**
    - `catch(err)`의 `err`는 거의 항상 `unknown` 또는 `any` 취급
2. **부작용(HTTP 요청, 파일 접근 등)에 대한 정보가 타입에 없음**
3. **취소(cancellation)**, **타임아웃**, **재시도(retry)** 등을 직접 구현하면 코드가 복잡해짐
4. 복잡한 비동기/동시성(예: 여러 작업을 합치기, 리소스 안전한 사용 등)을 관리하기가 어렵다

이제 이런 한계를 염두에 두고 **Effect**를 보면, 왜 “효과 시스템(effect system)”이 필요한지 감이 좀 더 잘 옵니다.

---

## 2. Effect TS(Effect-TS)란? (아주 가볍게)

> TypeScript에서 부작용, 비동기, 에러, 자원 관리 등을 타입 수준에서 모델링할 수 있게 제공하는 함수형 라이브러리.
> 
> 
> Scala의 ZIO에서 많은 영향을 받음. ([GitHub](https://github.com/mikearnaldi/effect-ts?utm_source=chatgpt.com))
> 

핵심 아이디어:

- “`Promise<A>`” 대신 **“`Effect<Success, Error, Requirements>`”** 라는 타입으로 표현
- 예: `Effect<string, Error, never>`
    - 성공하면 `string`
    - 실패하면 `Error`
    - 실행에 필요한 환경(`R`)은 `never` (없다)

초기 라이브러리는 `effect-ts` / 최근에는 그냥 `effect` 이름으로 발전된 프레임워크 형태로 제공 중.([GitHub](https://github.com/Effect-TS/effect?utm_source=chatgpt.com))

---

## 3. 단순 Promise ↔ Effect TS 비교 (코드 중심)

### 3-1. 일반 Promise 버전

### 1) 사용자 조회 후, 없으면 에러

```tsx
interface User {
  id: number;
  name: string;
}

function fetchUserPromise(id: number): Promise<User> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (id === 1) {
        resolve({ id: 1, name: "Leriel" });
      } else {
        reject(new Error("User not found"));
      }
    }, 300);
  });
}

async function getUserNameUpperPromise(id: number): Promise<string> {
  const user = await fetchUserPromise(id);
  return user.name.toUpperCase();
}

getUserNameUpperPromise(1)
  .then(console.log)
  .catch((err) => console.error("에러:", err));

```

---

### 3-2. Effect TS 스타일 (개념적)

Effect에서는 대략 이런 느낌으로 작성합니다:

```tsx
import * as Effect from "effect";

interface User {
  id: number;
  name: string;
}

type Error { 
  msg: string
}

// Effect<Error, User, never> 형태 (라이브러리 버전에 따라 타입 파라미터 순서는 다를 수 있음)
const fetchUserEffect = (id: number) =>
  Effect.async<User, Error, never>((resume) => {
    setTimeout(() => {
      if (id === 1) {
        resume(Effect.succeed({ id: 1, name: "Leriel" }));
      } else {
        resume(Effect.fail(new Error("User not found")));
      }
    }, 300);
  });

const getUserNameUpperEffect = (id: number) =>
  Effect.flatMap(fetchUserEffect(id), (user) =>
    Effect.succeed(user.name.toUpperCase())
  );

// 실행
Effect.runPromise(getUserNameUpperEffect(1))
  .then(console.log)
  .catch((err) => console.error("Effect 에러:", err));

```

여기서 중요한 포인트:

- **에러 타입이 명시적**: `Effect<Success, Error, Env>` 구조를 사용
- 실행(`runPromise`) 전까지는 **순수한 값**으로 남아 있음 → 테스트/조합이 쉬워짐

> 최신 Effect 공식 문서는 “Effect는 타입 안전한, 조합 가능한 비동기/동시성 프로그램을 만들기 위한 효과 시스템”이라고 소개합니다.(effect-ts.github.io)
> 

---

## 4. Effect TS를 쓰면 좋은 점 (장점)

### 4-1. 타입으로 보이는 에러 모델링

Promise:

```tsx
async function signIn(email: string, password: string): Promise<string> {
  // 실패하면 throw Error, 하지만 어떤 에러인지 타입에서는 알 수 없음
}

```

Effect:

```tsx
type SignInError =
  | { _tag: "InvalidEmailOrPassword" }
  | { _tag: "TooManyAttempts" };

const signIn = (
  email: string,
  password: string
) =>
  Effect.Effect<string, SignInError, never>;

```

- 콜 사이트에서 **어떤 에러가 발생할 수 있는지 타입으로 바로 확인 가능**
- `switch`로 패턴 매칭해서 누락된 케이스를 컴파일 타임에 잡을 수도 있음([Velog](https://velog.io/%40j_6367/Typescript%EC%9D%98-Effect-TS-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0?utm_source=chatgpt.com))

---

### 4-2. 풍부한 조합기(combinator)와 동시성 지원

Promise에서도 `Promise.all`, `race` 등이 있지만, Effect는 훨씬 더 많은 고수준 조합기를 제공합니다:

- `Effect.all`, `Effect.race`, `Effect.timeout`, `Effect.retry`, `Effect.zip`, …
- **동시 실행(concurrency)**, **취소(cancellation)**, **재시도 정책(backoff)**, **리소스 안전한 사용(bracket/Scoped)** 같은 것들을 라이브러리 레벨에서 제공([effect-ts.github.io](https://effect-ts.github.io/effect/?utm_source=chatgpt.com))

예: n번까지 재시도 + 타임아웃

```tsx
const fetchData = Effect.tryPromise({
  try: () => fetch("https://api.example.com/data").then((res) => res.json()),
  catch: (e) => new Error(String(e)),
});

const program = fetchData.pipe(
  Effect.timeout("5 seconds"),
  Effect.retry({
    times: 3,
  })
);

Effect.runPromise(program)
  .then(console.log)
  .catch((err) => console.error("실패:", err));

```

Promise로 직접 구현하려면:

- 타이머/카운터 관리
- fetch 실패/타임아웃/취소 등 세부 케이스 처리
    
    → 코드 양과 복잡도가 훨씬 커짐
    

---

### 4-3. 환경(Dependency) 주입을 타입으로

Effect에서는 “`Env`” 타입 파라미터를 통해 **어떤 의존성이 필요한지**를 타입으로 나타낼 수 있습니다. (예: DB, Logger, Config 등)

```tsx
interface HasLogger {
  logger: {
    log: (msg: string) => void;
  };
}

const logHello: Effect.Effect<void, never, HasLogger> = Effect.flatMap(
  Effect.context<HasLogger>(),
  (env) => Effect.sync(() => env.logger.log("Hello"))
);

```

- 테스트 시에는 Mock Logger를 넣고,
- 실제 실행에서는 실제 Logger를 넣는 식으로 **의존성 주입이 타입 안정성 있게 해결**됩니다.([DeepWiki](https://deepwiki.com/Effect-TS/effect?utm_source=chatgpt.com))

---

### 4-4. 순수 함수형 스타일 + 테스트 용이성

- Effect 값은 “지금 실행되지 않는, 실행 계획” 같은 것이라
    
    **테스트에서 실행/비실행을 제어**하고, 조합해서 큰 프로그램을 만들기 좋습니다.
    
- 함수형 프로그래밍 스타일에서 선호하는 참조 투명성(같은 입력 → 같은 출력)을 유지하기 쉬움.([DEV Community](https://dev.to/modgil_23/breaking-down-effect-ts-part-1-2e0i?utm_source=chatgpt.com))

---

## 5. Effect TS의 단점 / 고려사항

### 5-1. 러닝 커브 (학습 난이도)

- 기존 JS/TS 개발자 입장에서:
    - `Promise`, `async/await`만으로도 충분히 복잡한데,
    - **Monad, Effect, Fiber, Context, Layer** 같은 함수형 개념까지 들어옴
- 팀 전체가 이해하고 같이 쓰지 않으면
    
    일부 코드만 Effect 스타일, 나머지는 Promise 스타일 → **일관성 깨짐**
    

---

### 5-2. 라이브러리 의존성과 생태계

- 추가 의존성: 프로젝트에 `effect`를 얹으면 번들 사이즈, 빌드 설정 관리 등이 필요
- 팀이 떠받들고 있는 “공통 약속”이 많아짐:
    - “비즈니스 로직은 Effect로 쓰자”
    - “직접 new Promise 쓰지 말자” 등
- 생태계/도큐먼트는 많이 좋아졌지만, 여전히 **일반 Promise만큼 “당연한 기본기”는 아님**([effect.website](https://effect.website/?utm_source=chatgpt.com))

---

### 5-3. 기존 코드와의 인터롭

- 이미 Promise/async 기반 코드가 많은 환경에서는
    
    **기존 코드 <-> Effect 코드 사이를 연결하는 어댑터**가 필요
    
    - `Effect.tryPromise`, `Effect.runPromise` 등으로 감싸고 풀고 하는 작업
- 잘못 섞으면 “어디까지가 Effect고 어디부터가 그냥 Promise인지” 헷갈릴 수 있음

---

### 5-4. 과한 추상화 가능성

- 단순한 CRUD, 단순한 비동기 처리라면:
    - Plain `async/await`가 훨씬 읽기 쉽고 단순할 수 있음
- 프로젝트 규모/복잡도에 비해 **추상화 레벨이 과도**해질 위험이 있음
    - 팀 내에서 “언제 Effect를 도입할지” 기준이 필요

---