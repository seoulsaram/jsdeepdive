이벤트는 사용자의 행동이나 시스템에서 발생하는 모든 사건을 의미합니다. 자바스크립트는 이벤트가 발생했을 때 특정 동작을 수행하도록 하는 **이벤트 드리븐 프로그래밍**을 기반으로 동작합니다.

---

### 40.1 이벤트 드리븐 프로그래밍

이벤트 드리븐 프로그래밍은 **이벤트의 발생**을 중심으로 코드의 흐름이 결정되는 프로그래밍 모델입니다. 사용자가 버튼을 클릭하거나 키보드를 입력하는 등의 이벤트가 발생하면, 미리 등록해 둔 이벤트 핸들러(이벤트 리스너 함수)가 실행됩니다.

- **이벤트(Event)**: 웹페이지에서 발생하는 모든 사건 (예: 클릭, 입력, 스크롤)
- **이벤트 핸들러(Event Handler)**: 이벤트가 발생했을 때 실행되는 함수
- **이벤트 리스너(Event Listener)**: 특정 DOM 요소에서 발생하는 이벤트를 감지하고 이벤트 핸들러를 호출하는 역할

```jsx
const myButton = document.querySelector('#myButton');

// 'click' 이벤트가 발생하면 실행될 이벤트 핸들러
function onButtonClick() {
  console.log('버튼이 클릭되었습니다!');
}

// 버튼 요소에 'click' 이벤트 리스너를 등록하고 핸들러를 연결
myButton.addEventListener('click', onButtonClick);
```

---

### 40.2 이벤트 타입

이벤트는 발생 원인에 따라 다양한 종류로 나뉩니다. 약 200여가지..

MDN > Event reference 참고하기

### **40.2.1 마우스 이벤트 🖱️**

- `click`: 요소를 클릭했을 때
- `dblclick`: 요소를 더블 클릭했을 때
- `mousedown`: 마우스 버튼을 누르는 순간
- `mouseup`: 누르고 있던 마우스 버튼을 뗄 때
- `mousemove`: 마우스를 움직였을 때
- `mouseover` / `mouseout`: 마우스 포인터가 요소 위로 올라오거나 나갔을 때
- `mouseenter` / `mouseleave`: `mouseover`/`mouseout`과 유사하지만, 버블링이 발생하지 않습니다.

### **40.2.2 키보드 이벤트 ⌨️**

- `keydown`: 키를 누르는 순간
- `keyup`: 누르고 있던 키를 뗄 때
- `keypress`: 문자를 입력하는 키를 눌렀을 때 (현재는 `keydown` 사용이 권장됩니다)

### **40.2.3 포커스 이벤트**

- `focus`: 요소가 포커스를 얻었을 때 (예: 입력 필드 클릭) - 버블링x
- `blur`: 요소가 포커스를 잃었을 때 - 버블링x
- `focusin`: 요소가 포커스를 얻었을 때 - 버블링o
- `focusout`: 요소가 포커스를 잃었을 때 - 버블링o

### **40.2.4 폼 이벤트**

- `submit`: `<form>`이 제출될 때
- `reset`: `<form>`의 내용이 리셋될 때

### **40.2.5 값 변경 이벤트**

- `change`: `<input>`, `<select>`, `<textarea>`의 값이 변경되고 포커스를 잃었을 때
- `input`: 위의 요소들 값이 변경되는 **순간마다** 발생 (실시간 감지)

### **40.2.6 DOM 뮤테이션 이벤트**

- `DOMContentLoaded`: 브라우저가 HTML을 모두 읽고 DOM 트리를 완성했을 때 (이미지, CSS 등 외부 리소스 로딩 전)
    - 성능상의 이유로 현재는 **`MutationObserver`** 사용이 권장됩니다.

### **40.2.7 뷰 이벤트**

- `resize` : 윈도우의 크기를 리사이즈할 때
- `scroll`: 웹페이지 또는 HTML 요소를 스크롤할 때

### **40.2.8 리소스 이벤트**

- `load`: 리소스 로딩이 완료되었을 때
- `error`: 리소스 로딩에 실패했을 때
- `unload`: 리소스가 언로드될 때 (새로 요청 시)
- `abort`: 리소스 로딩 중단됐을 때

---

### 40.3 이벤트 핸들러 등록

이벤트 핸들러를 등록하는 세 가지 주요 방법입니다.

### **40.3.1 이벤트 핸들러 어트리뷰트 방식 (권장하지 않음 ❌)**

HTML 요소의 `on<이벤트타입>` 어트리뷰트에 직접 코드를 작성하는 방식입니다. HTML과 JavaScript가 혼재되어 유지보수가 어렵습니다.

```jsx
<button onclick="alert('버튼 클릭!')">클릭하세요</button>
```

### **40.3.2 이벤트 핸들러 프로퍼티 방식**

DOM 요소 객체의 프로퍼티에 핸들러 함수를 할당합니다. 하나의 이벤트에 하나의 핸들러만 등록할 수 있다는 단점이 있습니다.

```jsx
const button = document.querySelector('button');
button.onclick = function() {
  console.log('버튼이 클릭되었습니다.');
};

// 핸들러 교체 (이전 핸들러는 사라짐)
button.onclick = function() {
  console.log('새로운 핸들러가 등록되었습니다.');
};
```

### **40.3.3 addEventListener 메서드 방식 (권장 👍)**

가장 현대적이고 강력한 방법입니다. 하나의 이벤트에 여러 핸들러를 등록할 수 있으며, 이벤트 전파 제어 등 다양한 옵션을 제공합니다.

```jsx
const button = document.querySelector('button');

function handler1() {
  console.log('첫 번째 핸들러 실행');
}

function handler2() {
  console.log('두 번째 핸들러 실행');
}

// 하나의 'click' 이벤트에 두 개의 핸들러를 모두 등록
button.addEventListener('click', handler1);
button.addEventListener('click', handler2);
```

---

### 40.4 이벤트 핸들러 제거

`addEventListener`로 등록한 이벤트 핸들러는 `removeEventListener`로 제거할 수 있습니다. 제거 시에는 등록할 때 사용한 함수와 **정확히 동일한 참조**를 가진 함수를 전달해야 합니다. 따라서 익명 함수는 제거할 수 없습니다.

```jsx
const button = document.querySelector('button');

const handleClick2 = (i : string) = >{
	
}

const handleClick = () => {
  console.log('이 핸들러는 한 번만 실행됩니다.');
  button.removeEventListener('click', handleClick); // 자신을 제거
};

button.addEventListener('click', () => {
	console.log();
	button.removeEventListener('click', arguments.callee);
}
);

const handleChangeInput(x) => {
   x.target.value
}

<input onChange={handleChangeInput} />
```

---

### 40.5 이벤트 객체

이벤트가 발생하면, 브라우저는 해당 이벤트에 대한 상세 정보를 담은 **이벤트 객체**를 생성하여 이벤트 핸들러의 첫 번째 인자로 전달합니다. 

매개변수 e에 암묵적으로 할당됩니다. > 브라우저가 이벤트 핸들러 호출 시 이벤트 객체를 인수로 전달하기 때문.

- 이벤트 하나씩 파보기

- 다음주에 계속
    
    ### **40.5.1 이벤트 객체의 상속 구조**
    
    이벤트 객체는 상속을 통해 구성됩니다. 예를 들어, MouseEvent는 UIEvent를, UIEvent는 Event를 상속받습니다. 따라서 하위 이벤트 객체는 상위 객체의 모든 프로퍼티와 메서드를 사용할 수 있습니다.
    
    (예: Event ← UIEvent ← MouseEvent)
    
    ### **40.5.2 이벤트 객체의 공통 프로퍼티**
    
    - `type`: 이벤트 종류 (예: 'click')
    - `target`: 이벤트가 **실제로 발생한** DOM 요소
    - `currentTarget`: 이벤트 리스너가 **등록된** DOM 요소 (`this`와 동일)
    - `preventDefault()`: 브라우저의 기본 동작을 중단시키는 메서드 (예: 링크 이동 방지)
    - `stopPropagation()`: 이벤트 전파(버블링)를 중단시키는 메서드
    
    ### **40.5.3 마우스 정보 취득**
    
    - `clientX`, `clientY`: 브라우저 창(Viewport) 기준 마우스 좌표
    - `pageX`, `pageY`: 웹 문서 전체 기준 마우스 좌표
    - `offsetX`, `offsetY`: 이벤트 대상 요소 기준 마우스 좌표
    
    ### **40.5.4 키보드 정보 취득**
    
    - `key`: 사용자가 누른 키의 값 (예: 'a', 'Enter', 'Shift')
    - `code`: 사용자가 누른 키의 물리적인 위치 (예: 'KeyA', 'Enter', 'ShiftLeft')
    
    ```jsx
    const input = document.querySelector('input');
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        alert(`입력된 값: ${e.target.value}`);
      }
    });
    ```
    
    ---
    
    ### 40.6 이벤트 전파 (Event Propagation)
    
    DOM 요소에 이벤트가 발생하면, 이벤트는 DOM 트리를 따라 전파됩니다. 전파는 다음 3단계로 이루어집니다.
    
    1. **캡처링 단계 (Capturing Phase)**
        - 이벤트가 최상위 요소인 `window`에서 시작해, 이벤트가 발생한 **대상 요소까지 아래로 전파**되는 단계입니다.
        - 이벤트 핸들러를 `addEventListener`의 세 번째 인수를 `true`로 설정하면 이 단계에서 이벤트를 감지할 수 있습니다.
    2. **타겟 단계 (Target Phase)**
        - 이벤트가 실제로 발생한 **대상 요소에 도달**하는 단계입니다.
    3. **버블링 단계 (Bubbling Phase)**
        - 이벤트가 대상 요소에서 시작해, 다시 최상위 요소인 `window`까지 **위로 전파**되는 단계입니다.
        - `addEventListener`의 세 번째 인수를 생략하거나 `false`로 설정하면 기본적으로 이 단계에서 이벤트를 감지합니다. 대부분의 이벤트는 버블링을 기본으로 합니다.
    
    대부분의 이벤트 핸들러는 **버블링 단계**에서 동작합니다. `addEventListener`의 세 번째 인자에 `{ capture: true }` 옵션을 주면 캡처링 단계에서 이벤트를 감지할 수 있습니다.
    
    ---
    
    ### 40.7 이벤트 위임 (Event Delegation)
    
    **이벤트 위임**은 여러 자식 요소의 이벤트를 각각 처리하지 않고, 부모 요소에 하나의 이벤트 핸들러를 등록하여 처리하는 디자인 패턴입니다. 이벤트 버블링을 활용하여, 실제 이벤트 발생 대상(`event.target`)을 확인해 동작을 결정합니다.
    
    **장점**:
    
    - **동적 요소 처리**: 나중에 동적으로 추가되는 자식 요소에도 이벤트 핸들러가 자동으로 적용됩니다.
    - **성능 최적화**: 여러 개의 핸들러를 등록하는 것보다 메모리를 적게 사용하고 성능에 유리합니다.
    
    ```jsx
    <ul id="fruit-list">
      <li>사과</li>
      <li>바나나</li>
      <li>딸기</li>
    </ul>
    ```
    
    ```jsx
    const fruitList = document.getElementById('fruit-list');
    
    fruitList.addEventListener('click', function (event) {
      // event.target은 실제 클릭된 li 요소
      console.log(event.target.textContent);
    });
    ```
    
    ---
    
    ### 40.8 DOM 요소의 기본 동작 조작
    
    ### **40.8.1 DOM 요소의 기본 동작 중단**
    
    링크 클릭(`<a>`), 폼 제출(`submit`) 등 일부 DOM 요소는 고유한 기본 동작을 가지고 있어요. 이 동작을 막으려면 `event.preventDefault()` 메서드를 사용합니다.
    
    ```jsx
    const form = document.querySelector('form');
    form.addEventListener('submit', (e) => {
      e.preventDefault(); // 폼 제출 시 페이지가 새로고침되는 것을 막음
      console.log('폼 제출을 AJAX로 처리합니다.');
    });
    ```
    
    ### **40.8.2 이벤트 전파 방지**
    
    `event.stopPropagation()`을 호출하면 현재 요소의 이벤트 핸들러 실행 후, 상위 요소로의 이벤트 전파(버블링)를 즉시 중단합니다.
    
    ---
    
    ### 40.9 이벤트 핸들러 내부의 `this`
    
    ### 1. 이벤트 핸들러 어트리뷰트 방식
    
    HTML 요소의 어트리뷰트로 이벤트 핸들러를 등록할 경우, 이벤트 핸들러 함수는 **전역 객체(`window`)의 메서드**로 호출됩니다. 따라서 `this`는 `window` 객체를 가리킵니다.
    
    ```jsx
    <button onclick="console.log(this)">클릭하세요</button>
    ```
    
    만약 이벤트 핸들러 어트리뷰트 내에서 `this`를 사용하고 싶다면, 이벤트 객체를 의미하는 `event` 객체의 `target` 프로퍼티를 사용하는 것이 더 정확합니다.
    
    ```jsx
    <button onclick="console.log(event.target)">클릭하세요</button>
    ```
    
    > 이 방식은 HTML과 자바스크립트가 혼재되어 유지보수가 어렵기 때문에 권장되지 않습니다.
    > 
    
    ---
    
    ### 2. 이벤트 핸들러 프로퍼티 방식 & `addEventListener` 메서드 방식
    
    DOM 요소 객체의 프로퍼티나 `addEventListener` 메서드를 사용해서 이벤트 핸들러를 등록하는 것이 일반적입니다. 이 경우, `this`는 **이벤트 핸들러가 바인딩된 DOM 요소를 가리킵니다.**
    
    ```jsx
    const button = document.getElementById('myButton');
    
    // 이벤트 핸들러 프로퍼티 방식
    button.onclick = function () {
      console.log(this); // <button id="myButton">...</button>
    };
    
    // addEventListener 메서드 방식
    button.addEventListener('click', function () {
      console.log(this); // <button id="myButton">...</button>
    });
    ```
    
    위 코드에서 `this`는 모두 이벤트 리스너가 등록된 `button` 요소를 가리킵니다. 이를 통해 이벤트가 발생한 요소를 쉽게 참조할 수 있어 매우 편리합니다.
    
    ### 📌 주의할 점: 화살표 함수
    
    **화살표 함수**로 이벤트 핸들러를 정의하면 `this`의 동작이 달라집니다. 화살표 함수는 자신만의 `this` 바인딩을 생성하지 않고, **상위 스코프의 `this`를 상속**받습니다.
    
    ```jsx
    const button = document.getElementById('myButton');
    
    button.addEventListener('click', () => {
      console.log(this); // window 객체 
    });
    ```
    
    위 예제에서 화살표 함수는 전역 컨텍스트에서 정의되었기 때문에 `this`가 `window` 객체를 가리키게 됩니다. 따라서 이벤트가 발생한 요소를 참조하고 싶을 때는 일반 함수를 사용하거나, `event.currentTarget`을 사용하는 것이 좋습니다. `event.currentTarget`은 이벤트 핸들러가 바인딩된 요소를 정확히 가리킵니다.
    
    ```jsx
    const button = document.getElementById('myButton');
    
    button.addEventListener('click', (event) => {
      console.log(event.currentTarget); // <button id="myButton">...</button>
    });
    ```
    
    ---
    
    ### 40.10 이벤트 핸들러에 인수 전달
    
    `addEventListener`에 등록하는 핸들러 함수에는 일반적으로 인수(이벤트 객체)만 전달됩니다. 이벤트 핸들러에 추가적인 인수를 전달해야 할 경우, 핸들러를 감싸는 외부 함수(고차 함수)나 익명 함수를 사용합니다.
    
    ```jsx
    function sayHello(name) {
      console.log(`Hello, ${name}!`);
    }
    
    // 1. 익명 함수로 감싸기
    button.addEventListener('click', () => {
      sayHello('JavaScript');
    });
    
    // 2. .bind() 메서드 사용
    button.addEventListener('click', sayHello.bind(null, 'World'));
    ```
    
    ---
    
    ### 40.11 커스텀 이벤트
    
    개발자가 직접 이벤트를 정의하고 발생시킬 수 있습니다. 컴포넌트 간의 데이터 전달이나 상태 변화를 알릴 때 유용하게 사용됩니다.
    
    ### **40.11.1 커스텀 이벤트 생성**
    
    `CustomEvent` 생성자를 사용하여 이벤트를 만듭니다. `detail` 프로퍼티를 통해 원하는 데이터를 담을 수 있습니다.
    
    ```jsx
    const myCustomEvent = new CustomEvent('charge', {
      detail: {
        energy: '100%'
      }
    });
    ```
    
    ### **40.11.2 커스텀 이벤트 디스패치 (발생)**
    
    `dispatchEvent` 메서드를 사용하여 특정 요소에서 이벤트를 발생시킵니다.
    
    ```jsx
    const robot = document.querySelector('.robot');
    
    // 커스텀 이벤트 리스너 등록
    robot.addEventListener('charge', (e) => {
      console.log(`로봇의 에너지가 ${e.detail.energy}로 충전되었습니다.`);
    });
    
    // 버튼 클릭 시 커스텀 이벤트 발생
    document.querySelector('#chargeButton').addEventListener('click', () => {
      robot.dispatchEvent(myCustomEvent);
    });
    ```
    
    —  커스텀이벤트 등록하는 방법  — 
    
    [https://mong-blog.tistory.com/entry/JS-커스텀-이벤트를-만드는-2가지-방법Event-CustomEvent](https://mong-blog.tistory.com/entry/JS-%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%9D%B4%EB%B2%A4%ED%8A%B8%EB%A5%BC-%EB%A7%8C%EB%93%9C%EB%8A%94-2%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95Event-CustomEvent)