
## 공백 텍스트 노드

아래와 같은 공백 문자는 텍스트 노드를 생성한다 :

- HTML요소 사이의 스페이스
- 탭
- 줄바꿈(개행)
- 그 외 공백

이를 <u>공백 텍스트 노드</u>라고 한다.


```html

<!-- 🧐 ul밑에 몇 개의 노드가 있을까?  -->
<ul id="fruits">
    <li class="apple">Apple</li>
    <li class="banana">Banana</li>
    <li class="orange">Orange</li>
</ul>
```

![[스크린샷 2025-08-21 오전 9.09.58.png]]

인위적으로 공백을 없애면 공백 노드가 생기지 않음
```html
    <ul id="fruits"><li class="apple">Apple</li><li class="banana">Banana</li><li class="orange">Orange</li></ul>
```

---

## 자식 노드 탐색

- `Node.prototype.childNodes`
	- 자식 노드를 모두 탐색하여 NodeList로 반환
	- `childNodes` 프로퍼티가 만환한 NodeList에는 요소노드 뿐 아니라 텍스트 노드도 포함되어 있을 수 있다. 
- `Element.prototype.children`
	- 자식 노드 중에서 요소 노드만 모두 탐색하여 HTMLCollection으로 반환
	- Element에는 텍스트노드가 포함되지 않음
- `Node.prototype.firstChild`
	- 첫번째 자식 노드 반환.
	- 텍스트 노드 or 요소 노드가 반환됨
- `Node.prototype.lastChild`
	- 마지막 자식 노드 반환.
	- 텍스트 노드 or 요소 노드가 반환됨
- `Element.prototype.firstElementChild`
	- 첫번째 자식 노드 반환.
	- 요소 노드만 반환
- `Element.prototype.lastElementChild`
	- 마지막 자식 노드 반환.
	- 요소 노드만 반환.


### 🧩 실습

```html
<ul id="fruits">
    <li class="apple">Apple</li>
    <li class="banana">Banana</li>
    <li class="orange">Orange</li>
</ul>
```

1. ul에서 <u>자식 노드</u>들 찾기. 텍스트 노드는 제외.
2. ul에서 <u>첫번째 노드만</u> 찾기. 텍스트 노드 or 요소 노드일 수 있음.
3. ul에서 <u>마지막 노드만</u> 찾기. 텍스트 노드는 제외.

---
## 자식 노드 존재 확인

`Node.prototype.hasChildNodes`
- 자식 노드가 존재하는지 확인하는 메서드
- boolean값을 리턴
- 텍스트 노드까지 포함해서 검사

```js
const ul = document.getElementById("fruits");

console.log(ul.hasChildNodes()); //true
```

텍스트노드 제외한 요소 노드 존재만 확인하려면 :
`Element.prototype.childElementCount`
- 프로퍼티이기 때문에 값을 number로 반환
`Element.prototype.children.length`
- 요소 노드들의 length로 확인하는 방법도 있음

```js
const ul = document.getElementById("fruits");

console.log(ul.childElementCount); //3
console.log(ul.children.length); //3
```
``

#### 📚 퀴즈 - 출력 결과는?
💡 힌트 : 
- childNodes는 `Node.prototype.childNodes` 이다.
- Node의 인터페이스 트리 보기
```html
    <ul id="fruits">
      <!-- 코멘트 -->
      <li class="apple">Apple</li>
      <li class="banana">Banana</li>
      <li class="orange">Orange</li>
    </ul>
```

```js
const ul = document.getElementById("fruits");
console.log(ul.children.length); // ?
console.log(ul.childNodes.length); // ?
```

---

## 요소 노드의 텍스트 노드 탐색

요소 노드의 텍스트 노드는 요소 노드의 자식 노드이므로
`firstChild` 프로퍼티로 접근할 수 있다.

```js
<div id="foo">Hello world</div>

const div = document.getElementById("foo");
console.log(div.firstChild); //"Hello world"
```

🧐 여기서 나의 의문점
> div는 Element인데 어떻게 CharacterData > Text에 접근가능한거지?

👉 div는 HTMLElement로서 Node, Element인터페이스를 모두 상속받아서 
CharacterData > Text에 접근할 수 있는 `Node.prototype` 메서드를 사용해서 접근할 수 있는 것

---

## 부모 노드 탐색

- `Node.prototype.parentNode`
	- Node인터페이스 프로퍼티이지만,
	- 텍스트 노드는 DOM트리의 최종단 리프 노드이므로 부모 노드가 텍스트 노드인 경우는 없음

```js
<div id="parent">
  <div id="foo">Hello world</div>
</div>

const div = document.getElementById("foo");
console.log(div.parentNode); //div#parent
```

---

## 그 외 탐색 메서드

- `Node.prototype.previousSibling`
- `Node.prototype.nextSibling`
- `Element.prototype.previousElementSibling`
- `Element.prototype.nextElementSibling`

#### 📚 퀴즈
```html
   <ul id="fruits">
      <!-- 코멘트 -->
      <li class="apple">Apple</li>
      <li class="banana">Banana</li>
      <li class="orange">Orange</li>
   </ul>
```

1. 코멘트 노드를 출력해보자
2. Orange li요소를 출력해보자
3. ul의 자식 요소 갯수를 출력하되, 요소 노드의 갯수만 출력해보자
4. Apple li요소를 찾고, 해당 요소를 통해 Banana를 찾아 출력해보자

---

## 노드 정보 취득

`Node.prototype.nodeType`
- 노드 객체의 종류, 즉 노드 타입을 나타내는 상수 반환

`Node.prototype.nodeName`
- 노드의 이름을 문자열로 반환
- 요소 노드 : 대문자 문자열로 태그 이름 반환
	- `document.getElementById("fruits").nodeName; //UL`
- 텍스트 노드 : `#text` 반환

---
## 요소 노드의 텍스트 조작

### `Node.prototype.nodeValue`

- getter,setter 모두 존재하는 접근자 프로퍼티
- 노드 객체의 `nodeValue` 프로퍼티를 참조하면 노드 객체의 값을 반환함
- 노드 객체의 값이란 텍스트 노드의 텍스트.
- 텍스트 노드가 아닌 노드의 nodeValue를 참조하면 null 반환

```js
<div id="foo">Hello world</div>

const div = document.getElementById("foo");
console.log(div.firstChild.nodeValue)
div.firstChild.nodeValue = 'Goodnight world!'
```

### `Node.prototype.textContent`

- getter, setter 모두 존재하는 접근자 프로퍼티
- 요소 노드의 텍스트와 모든 자손 노드의 텍스트를 모두 취득/변경함
- 요소 노드의 텍스트를 모두 취득할 때 HTML마크업은 무시된다.
- textContent 프로퍼티에 문자열을 할당하면
	- 요소 노드의 모든 자식 노드가 제거되고
	- 할당한 문자열이 텍스트로 추가됨
	- 할당한 문자열에 HTML마크업이 포함되어 있더라도 문자열로 인식되어 텍스트로 추가됨

```js
<div id="foo">Hello world
  <p>Javascript</p>
  <span>is fun!</span>
</div>


const div = document.getElementById("foo");

//💡 요소 노드의 텍스트를 모두 취득할 때 HTML마크업은 무시된다.
console.log(div.textContent); 
//Hello world
//  Javascript
//  is fun!

console.log(div.childNodes); // [text, p, text, span, text]


div.textContent = "<li>자바스크립트는 너무 재밌어</li>"
// 할당한 문자열만 남음
console.log(div.childNodes); // [text]
```


##### ❌ 👎🏻 `innerText`도 `textContent`와 유사한 동작을 하지만 사용은 비추
- innerText 프로퍼티는 브라우저의 렌더링 결과를 기준으로 텍스트를 반환하기 때문에 CSS의 영향을 받는다.
- 예를들어, innerText 프로퍼티는 CSS에 의해 비표시로 지정된 요소 노드의 텍스트를 반환하지 않는다. (ex:visibility:hidden;)
- 즉, 눈에 보이는 텍스트만 반환함.

```js
<div id="foo">Hello world
  <p>Javascript</p>
  <span>is fun!</span>
</div>

<style>
  #foo{
    visibility: hidden;
  }
</style>

const div = document.getElementById("foo");
console.log(div.innerText); //출력되지 않음
```

- innerText 프로퍼티는 CSS를 고려하느라 textContent보다 느리다.

---

## DOM 조작

> DOM 조작이란 :
>  - 새로운 노드를 생성하여 DOM에 추가하거나
>  - 기존 노드를 삭제 또는 교체하는 것

DOM을 조작하면 리플로우와 리페인트가 발생하므로 성능에 영향을 준다.
(새로운 노드가 추가/삭제되면)
그렇기 때문에 DOM 조작은 성능 최적화를 위해 주의해서 다루어야 함.

> 리플로우란?
> 브라우저가 레이아웃(배치)를 다시 계산하는 과정.

리플로우는 언제 발생하나?
- DOM 구조 변경
	- 노드 추가/삭제될 때
	- `appendChild`, `removeChild`
- 요소의 크기/위치 변경
	- `width`, `height`, `margin`, `padding`, `border` 변경
	- `position`, `top`, `left` 등 좌표 변경
- 윈도우 리사이즈
	- 뷰포트 크기가 바뀌면 전체 레이아웃 재계산
- 폰트나 텍스트 변경
	- `font-size`, `line-height`, 문자 내용 변경
- 계산된 레이아웃을 강제로 읽을 때
	- `offsetWidth`, `offsetHeight`, `getComputedStyle()`같은 프로퍼티 접근 시
		- 브라우저가 최신 레이아웃 계산을 먼저 수행해야 값 반환 가능하기 때문에.

리페인트와 리플로우 차이
- 리플로우 : 레이아웃 다시 계산 -> 비용 큼
- 리페인트 : 레이아웃은 그대로, 색상/배경 같은 시각적 속성만 다시 그림


### `Element.prototype.innerHTML`

- setter, getter 접근자 프로퍼티
- 요소 노드의 HTML마크업을 취득/변경함
- 요소 노드의 콘텐츠 영역(시작 태그와 종료 태그 사이) 내의 모든 HTML 마크업을 문자열로 반환

```js
<div id="foo">Hello world
  <p>Javascript</p>
  <span>is fun!</span>
</div>

const div = document.getElementById("foo");
console.log(div.innerHTML);

//Hello world
//  <p>Javascript</p>
//  <span>is fun!</span>
```

- innerHTML프로퍼티에 문자열을 할당 -> 모든 자식 노드가 제거되고 할당한 문자열만 자식 노드로
- 마크업을 문자열로 할당할 경우 파싱되어 요소 노드로 추가됨
- 이걸 이용해 요소 노드를 추가/삭제 할 수도 있다.

```js
const div = document.getElementById("foo");
console.log(div.innerHTML);


div.innerHTML = "퇴근~"

console.log(div.innerHTML); //퇴근~

div.innerHTML = "<ul><li>리스트</li></ul>"

console.log(div.innerHTML); //<ul><li>리스트</li></ul>
```

- innerHTML에 사용자로부터 입력받은 데이터를 그대로 할당하는 것은 크로스 사이트 스크립트 공격(XSS)에 취약하므로 위험하다.

> 💡팁 - DOMPurify 사용하기
> 
> 사용자로부터 입력받은 데이터에서 잠재적 위험을 내포한 HTML 마크업을 살균해주는 라이브러리

```js

DOMPurify.sanitize('<img src="x" onerror="alert(document.cookie)"/>');
// => <img src="x"/>
```

innerHTML의 단점:
- 자식 노드를 모두 제거하고 -> 할당된 값을 그리기 때문에 리플로우가 많이 발생
- 새로운 요소 삽입 시 삽입될 위치를 지정할 수 없음



### `Element.prototype.insertAdjacentHTML(psition, DOMString)`

- 기존 요소를 제거하지 않으면서 위치를 지정해 새로운 요소 삽입
- position인자
	- beforebegin
	- afterbegin
	- beforeend
	- afterend
![[스크린샷 2025-08-21 오전 10.26.17.png]]

- innerHTML보다 빠르고 효율적
- XSS에 취약하다는 점은 동일

```js
<div id="foo">Hello world
  <p>Javascript</p>
  <span>is fun!</span>
</div>

const div = document.getElementById("foo");
div.firstElementChild.insertAdjacentHTML('beforebegin','<p style="color:blue;">안뇽 세상아</p>')
```

---
## 노드 생성과 추가

### 생성 및 삽입

`Document.prototype.createElement(tagName)`
- 요소 노드를 생성하여 반환
- 매게변수에는 태그 이름을 나타내는 문자열을 인수로 전달한다
- `const li = document.createElement('li');`
- 생성된 노드를 DOM에 추가하는 처리를 별도로 해주어야 함.


`Document.prototype.createTextNode(text)`
- 텍스트 노드를 생성하여 반환
- 생성된 노드를 DOM에 추가하는 처리를 별도로 해주어야 함.

`Node.prototype.appendChild(childNode)`
- appendChild를 호출한 노드의 마지막 노드로 childNode가 추가됨
- 리플로우, 리페인트가 발생하므로
	- 요소를 생성하는 과정(createElement, createTextNode)가 여러번 필요한 경우
	- appendChild는 요소가 모두 생성된 뒤 마지막에 한번만 실행시키는 것이 좋음

```js
<ul id="fruits"></ul>


const ul = document.getElementById('fruits');

//1. 컨테이너 노드 생성
const div = document.createElement('div');

['Apple','Banana'].forEach((text)=> {
  //2. 추가할 요소노드 생성
  const li = document.createElement('li');

  //3. 요소 노드에 넣을 컨텐츠 생성
  const textNode = document.createTextNode(text);

  //4. 요소노드에 컨텐츠 삽입
  li.appendChild(textNode);

  //5. 컨테이너 마지막 자식 노드로 li추가
  div.appendChild(li)
});

//6. 완성된 컨테이너 요소를 ul요소노드의 마지막 자식 노드로 추가
ul.appendChild(div)
```

이때 1번 컨테이너 노드는 불필요한 요소이다. (리플로우,리페인트 방지를 위해서만 있는 요소)
![[스크린샷 2025-08-21 오전 10.51.54.png]]

이러한 문제를 `DocumentFragment` 노드로 해결할 수 있다.
- `DocumentFragment` 노드는 문서, 요소, 어트리뷰트, 텍스트노드와 같은 노드 객체의 일종.
- 부모 노드가 없어서 기존 DOM과는 별도로 존재한다.
- `DocumentFragment`노드는 위 예제의 컨테이너 요소와 같이 자식 노드들의 부모 노드로서 별도의 서브 DOM을 구성하여 기존 DOM에 추가하기 위한 용도로 사용함
- `DocumentFragment`는 기존 DOM과는 별도로 존재하므로 자식 노드를 추가하여도 기존 DOM에는 어떤 변경도 발생하지 않는다.
- 또한 `DocumentFragment`노드를 DOM에 추가하면 자신은 제거되고 자신의 자식 노드만 DOM에 추가된다.
- `Document.prototype.createDocumentFragment` 메서드는 비어있는 `DocumentFragment`를 생성하여 반환한다.


![[스크린샷 2025-08-21 오전 10.51.06.png]]

변경 후
```js


const ul = document.getElementById('fruits');

//1. 컨테이너 노드 생성
const fragment = document.createDocumentFragment();

['Apple','Banana'].forEach((text)=> {
  //2. 추가할 요소노드 생성
  const li = document.createElement('li');

  //3. 요소 노드에 넣을 컨텐츠 생성
  const textNode = document.createTextNode(text);

  //4. 요소노드에 컨텐츠 삽입
  li.appendChild(textNode);

  //5. 컨테이너 마지막 자식 노드로 li추가
  fragment.appendChild(li)
});

//6. 완성된 컨테이너 요소를 ul요소노드의 마지막 자식 노드로 추가
ul.appendChild(fragment)
```

![[스크린샷 2025-08-21 오전 10.53.52.png]]


`Node.prototype.insertBefore(newNode, childNode)`
- 첫 번째 인수로 전달받은 노드를 두번째 인수로 전달받은 노드 앞에 삽입함.
- 두번째 인수로 받은 노드는 반드시 insertBefore메서드를 호출한 노드의 자식 노드여야 함. 아닐 경우 DOMException발생
- 두 번째 인자가 null이면 자동으로 마지막 자식 노드로 추가된다. (`appendChild`처럼 동작)

```js
const ul = document.getElementById('fruits');

const li = document.createElement('li');
li.appendChild(document.createTextNode('Orange'));

ul.insertBefore(li, ul.firstElementChild);

const anonymous = document.getElementById('anonymous');
div.insertBefore(li, ul.firstElementChild); //DOMException발생
```



### 노드 복사

`Node.prototype.cloenNode([deep: true | false])`
- 노드의 사본을 생성하여 반환
- 매개변수 deep에 true를 전달하면 노드를 깊은 복사한다.
- 깊은 복사의 경우 모든 자손 노드가 포함된 사본을 생성
- 얕은 복사일 경우 노드 자신만의 사본을 생성함
- 얕은 복사일 경우 자식 노드는 복사가 되지 않기 때문에 텍스트 노드도 복사되지 않음주의

```js
<div id="fruits">안녕</div>


const div = document.getElementById('fruits');

const cloneShallow = div.cloneNode(false); //'안녕' 이라는 텍스트 노드도 없음
const cloneDeep = div.cloneNode(true);
```


### 노드 교체

`Node.prototype.replaceChlid(newChild, oldChild)`
- 자신을 호출한 노드의 자식 노드를 다른 노드로 교체함
- 첫번째 매개변수로 교체할 새 노드를
- 두번째 매개변수로 이미 존재하는 교체될 노드를 전달한다
- oldChild 인수로 전달한 노드는 replaceChild를 호출한 노드의 자식 노드여야 한다.

```js
<div id="fruits">텍스트</div>

const div = document.getElementById('fruits');

const span = document.createElement('span');
span.appendChild(document.createTextNode('싹싹김치'));

div.replaceChild(span, div.firstChild)
```


### 노드 삭제
`Node.prototype.removeChld(child)`
- 매게변수에 인수로 전달한 노드를 DOM에서 삭제함
- 인수로 전달한 노드는 removeChild를 호출한 노드의 자식노드여야 함.

```js
const div = document.getElementById('fruits');

div.removeChild(div.firstChild);
```