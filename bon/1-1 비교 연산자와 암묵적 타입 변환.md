
# 7.3 비교 연산자 (p.80)


```js

// == : 동등비교. x == y x와 y의 값이 같음
// === : 일치 비교. x === y x와 y의 값과 타입이 같음
// != : 부동등 비교. x != y x와 y의 값이 다름
// !== : 불일치 비교. x !== y x와 y의 값과 타입이 다름

동등비교(==)는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치키신 후 같은 값인지 비교한다.

5 == 5; // true
5 == '5'; // true

결과 예측이 어렵고 실수하기 쉬움.

'0' == ''; // false
0 == ''; // true
0 == '0' // true
false == 'false'; // false
false == '0'; // true
false == null; // false
false == undefined; // false

일치비교(===)는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다.
암묵적 타입 변환을 하지 않고 값을 비교한다.

5 === 5 // true
5 === '5' // false

```

## Object.is 

일치비교 연산자에서 주의할 것은 NaN이다.
NaN은 어떤 값과도 같지 않다. 심지어 자기 자신과도 일치하지 않는 유일한 값이다.
따라서 숫자가 NaN인지 검사하려면 빌트인함수 Number.isNaN을 사용한다.

```js
Number.isNaN(NaN) // true
Number.isNaN(10) // true
Number.isNaN(1+undefined) //true

NaN === NaN //false
NaN === 1 //false
NaN === 'one'//false

```

숫자 0도 주의. 자바스크립트에서는 양의 0과 음의 0이 있는데 이들을 비교하면 true를 반환한다.
```js

0 === -0 //true
0 == -0 // true


ES6에서 도입된 Object.js메서드는 isNaN, 0과 -0을 검사할 때 정확한 결과를 반환한다.
그 외에는 일치 비교 연산자(===)와 동일하게 동작한다.


-0 === 0 // true
Object.is(-0,0) //false
NaN === NaN; // false
Object.is(NaN,NaN) // true

```



## 타입변환 (p.108)

개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스트라고 한다면, 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 것을 암묵적 타입 변환이라 한다.

```js
// 옛날 js코드에서 자주 보였던 타입캐스트 형식
1 + '' 
```

### 문자열 타입으로 변환

`+` 연산자는 피연산자 중 하나 이상이 문자열일 경우 **문자열 연결 연산자**로 동작한다.
문자열 연결 연산자의 역할은 문자열 값을 만드는 것이므로, 피연산자 중 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입변 환한다.

```js
0 + "" // "0"
-0 + "" // "0"
NaN + "" // "NaN"
Infinity + "" // "Infinity"

true + "" // "true"
null + "" // "null"
undefined + "" // "undefined"

((Symbol())) + "" // TypeError


// 객체 타입
({}) + '' // "[object Object]"
Math + '' // "[object Math]"
[] + '' // ''
[10,20] + '' // 10,20 join함수 사용한것과 같음

```


### 숫자 타입으로 변환
`-`, `*`, `/` 연산자는 모두 산술 연산자다.
산술 연산자의 역할은 숫자 값을 만드는 것이므로 산술 연산자의 모든 피연산자는 숫자 타입이어야 한다.
때문에 피연산자가 숫자 타입이 아닌 경우 암묵적으로 숫자 타입 변환을 하는데,
숫자 타입으로 변환할 수 없는 경우 산술 연산을 수행할 수 없으므로 표현식 평가 결과는 NaN이 된다.

```js

1 - '1' //0
1 * '10' //10
1 / '10' //0.1
1 / 'one' //NaN

```


비교연산자의 역할은 불리언 값을 만드는 것이다.
이때 `>` 비교연산자는 피연산자의 크기를 비교하므로 모든 피연산자는 숫자 타입이어야 한다.
때문에 이 경우에도 피연산자를 암묵적 숫자 타입으로 변환한다.

```js
'1' > 0 // true
'one' > 0 //false
'one' < 0 //false

// 'one'은 형변환 했을 때 NaN이 나오는데
// 어떤 수를 `NaN`과 비교하면 항상 false가 나옴
```

`+` 연산자가 **단항 연산자**로 쓰일 경우 (이건 덧셈이 아님!) 단항 `+`는 문자열을 숫자로 **강제 변환 (type coercion)**함

```js
+ '' // 0
+ '0' // 0
+ '1' //1

+true //1
+false //0

+null //0
+undefined // NaN

+{} // NaN
+[] // 0
+[10,20] //NaN
+(function(){}) //NaN

```

### 주의사항
null, undefined 모두 falsy한 값이지만 undefined은 숫자 형변환이 안 된다.

```js
null + 1 // 1
undefined + 1 // NaN

Number(null) //0
Number(undefined) //NaN

+null //0
+undefined // NaN

```


### 불리언 타입으로 변환

if문, for문, 삼항 조건 연산자의 조건식은 불리언 값으로 평가되어야 하는 표현식이다.
이러한 문맥에서 사용된 조건은 불리언 타입으로 암묵적 변환된다.

```js

if('') //수행 안됨
if(true)  //수행 됨
if(0) //수행 안됨
if('str') //수행됨
if(null) //수행 안됨

if({}) //수행 됨
if([]) //수행 됨

if([]) 는 숫자 타입으로 변환하면 0이 나오지만 boolean으로 변환하면 true가 나온다.

```