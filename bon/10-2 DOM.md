
## 요소 노드를 취득하는 방법들

### `Document.prototype.getElementById`

```js
<ul>
    <li id="apple">Apple</li>
    <li id="banana">Banana</li>
    <li id="kiwi">Kiwi</li>
</ul>

const elem = document.getElementById('apple');
elem.style.color = 'red';
```

- HTML문서 내에서 중복된 id값을 갖는 HTML요소가 여러개 있어도, id값을 갖는 첫 번째 요소 노드만 반환한다.
- 만약 인수로 전달된 id를 가진 HTML요소가 없을 경우 getElementById 메서드는 null을 반환한다.


⭐️ HTML요소에 id 어트리뷰트를 부여하면 id값과 동일한 이름의 전역 변수가 암묵적으로 선언되고 해당 노드 객체가 할당되는 부수 효과가 있다.
```js
<ul>
    <li id="apple">Apple</li>
    <li id="banana">Banana</li>
    <li id="kiwi">Kiwi</li>
</ul>

console.log(apple); //li#apple
console.log(apple === document.getElementById('apple')); //true

// 암묵적 전역으로 생성된 전역 "프로퍼티"는 삭제되지만 전역 변수는 삭제되지 않는다.
delete apple;
console.log(apple); //li#apple 👉삭제되지 않음
```

- id값과 동일한 이름의 전역 변수가 이미 선언되어 있으면 이 전역 변수에 노드 객체가 재할당 되지 않는다.

```js
<ul>
    <li id="apple">Apple</li>
    <li id="banana">Banana</li>
    <li id="kiwi">Kiwi</li>
</ul>

var apple = "apple";
console.log(apple); //apple
```


암묵적 전역으로 생성된 프로퍼티의 경우 :
```js
test = "test";
console.log(test); //test

delete test;
console.log(test); //ReferenceError
```


---

### `getElementsByTagName`

- 여러 개의 요소 노드 객체를 갖는 DOM 컬렉션 객체인 `HTMLCollection`객체를 반환한다.
- 인수로 전달된 태그 이름을 갖는 요소가 없으면 빈 `HTMLCollection` 객체를 반환한다.

getElementsByTagName은 두 인터페이스로부터 상속받는다 :
- `Document.prototype.getElementsByTagName`
- `Element.prototype.getElementsByTagName`

차이점 :
- `document.getElementsByTagName('div')`
	- 문서 전체에서 `<div>`를 전부 찾음
- `someElement.getElementsByTagName('div')`
	- 해당 요소 내부에서만 `<div>`를 찾음.
- 즉 범위만 다르고, 기능은 동일

```js
<ul id="ul">
    <li id="apple">Apple</li>
    <li id="banana">Banana</li>
    <li id="kiwi">Kiwi</li>
</ul>

// Document.prototype.getElementsByTagName
const li = document.getElementsByTagName('li');

const ul = document.getElementById('ul');
// Element.prototype.getElementsByTagName
const li2 = ul.getElementsByTagName('li');
```

HTML문서의 모든 요소 노드를 취득하려면 :
```js
const all = document.getElementsByTagName('*');
```

---

### `getElementsByClassName`

- `HTMLCollection`객체를 반환
- 인수로 전달할 class는 공백으로 구분하여 여러 개의 class를 지정할 수 있다.
	- `getElementsByClassName('fruit apple')`
- 인수로 전달된 class값을 갖는 요소가 없으면 빈 `HTMLCollection` 객체를 반환한다.

getElementsByClassName 두 인터페이스로부터 상속받는다 :
- `Document.prototype.getElementsByClassName`
- `Element.prototype.getElementsByClassName`

```js
<ul id="ul">
    <li class="apple">Apple</li>
    <li class="apple banana">Apple</li> ✅
    <li class="banana">Banana</li>
    <li class="kiwi">Kiwi</li>
</ul>

const fruits = document.getElementsByClassName('apple banana');
console.log('fruits',fruits);  //HTMLCollection [li.apple.banana]
```

---

### `querySelector`

- CSS 선택자를 이용한 요소 노드 취득방법이다.
- 인수로 전달한 CSS 선택자를 만족시키는 하나의 요소 노드를 반환한다.
	- 여러개의 요소 노드가 있더라도 첫 번째 요소 노드만 반환
	- 찾아진 요소 노드가 없는 경우 null 반환
	- 인수로 전달한 CSS 선택자가 문법에 맞지 않으면 `DOMException`에러 발생


```js
<ul id="ul">
    <li class="apple">Apple</li>
    <li class="apple">Apple2</li>
    <li class="apple banana">Apple</li>
    <li class="banana">Banana</li>
    <li class="kiwi">Kiwi</li>
</ul>

// 여러개의 요소 노드가 있더라도 첫 번째 요소 노드만 반환
const fruit = document.querySelector('.apple');
console.log('fruit',fruit); //li.apple

// 찾아진 요소 노드가 없는 경우 null 반환
const fruit = document.querySelector('.tv');
console.log('fruit',fruit); //null

// 인수로 전달한 CSS 선택자가 문법에 맞지 않으면 `DOMException`에러 발생
const fruit = document.querySelector('@$sldkfj'); //Uncaught SyntaxError: '@$sldkfj' is not a valid selector
```


querySelector는 두 인터페이스로부터 상속받는다 :
- `Document.prototype.querySelector`
- `Element.prototype.querySelector`

---
### `querySelectorAll`

- 인수로 전달한 CSS 선택자를 만족시키는 모든 요소 노드를 탐색하여 반환한다.
- 반환하는 데이터는 여러 개의 요소 노드 객체를 갖는 DOM컬렉션 객체인 `NodeList`를 반환
	- 찾아진 요소가 없는 경우 빈 NodeList객체 반환
	- 인수로 전달한 CSS 선택자가 문법에 맞지 않으면 `DOMException`에러 발생


querySelectorAll 두 인터페이스로부터 상속받는다 :
- `Document.prototype.querySelectorAll`
- `Element.prototype.querySelectorAll`

```js
<ul id="ul">
    <li class="apple">Apple</li> ✅
    <li class="apple">Apple2</li> ✅
    <li class="apple banana">Apple</li> ✅
    <li class="banana">Banana</li>
    <li class="kiwi">Kiwi</li>
</ul>


const fruits = document.querySelectorAll('.apple');
console.log('fruits',fruits); // NodeList(3) [li.apple, li.apple, li.apple.banana]
```


HTML문서의 모든 요소 노드를 취득하려면 :
```js
const all = document.querySelectorAll('*');
```

---
## 특정 요소 노드를 취득할 수 있는지 확인

### `Element.prototype.matches`
- 인수로 전달한 CSS선택자를 통해 특정 요소 노드를 취득할 수 있는지 확인한다.

```js
<ul id="ul">
    <li class="apple">Apple</li>
    <li class="banana">Banana</li>
    <li class="kiwi">Kiwi</li>
</ul>

const apple = document.querySelector('.apple');

// apple노드는 '.apple'로 취득할 수 있다.
console.log(apple.matches('.apple')); //true

// apple노드는 'ul > .apple'로 취득할 수 있다.
console.log(apple.matches('ul > .apple')); //true

// apple노드는 'ul .banana'로 취득할 수 없다.
console.log(apple.matches('ul .banana')); //false
```

---

## HTMLCollection과 NodeList

- 이 둘은 DOM컬렉션 객체다.
- 유사 배열 객체이면서 이터러블이다.
- DOM API가 여러 개의 결과값을 반환하기 위해 사용하는 객체 타입.
- `for...of`문으로 순회할 수 있다.
- 스프레드 문법을 사용해 간단히 배열로 변환할 수 있다.

---
### HTMLCollection
- `getElementsByTagName`, `getElementsByClassName` 메서드가 반환하는 객체 타입
- 노드 객체의 상태 변화를 실시간으로 반영하는 살아있는 DOM컬렉션 객체
- 살아있는 객체라고 부르기도 함

📚 아래 결과 화면 예상해보기
```js
<ul id="fruits">
    <li class="blue">Apple</li>
    <li class="red">Banana</li>
    <li class="red">Kiwi</li>
</ul>

<style>
  .red { color: red; }
  .blue { color: blue; }
</style>


const elems = document.getElementsByClassName('red');
console.log(elems); //HTMLCollection(3) [li.red, li.red, li.red]

for(let i=0; i<elems.length; i++){
  elems[i].className = 'blue';
}

console.log(elems); // ?
```

- 위 코드는 세 개의 리스트 class가 blue로 바뀔 것이라고 예상된다.
- 하지만 두 번째 요소인 Banana만 class가 바뀌지 않는다.
- 첫번째 반복 (`i === 0`)
	- 첫번째 li요소의 class값이 'red'->'blue로 변경됨
	- `getElementsByClassName`메서드의 인자로 전달한 'red'와 더는 일치하지 않기 때문에 실시간으로 `elemes`에서 제거됨
- 두번째 반복 (`i === 1`)
	- 첫번째 반복에서 첫번째 li요소가 `elems`에서 제거되었으므로 `elems[1]`은 세번째 li요소가 됨.
	- 세번째 li의 class값이 'red'->'blue'로 변경됨
	- 실시간으로 `elems`에서 제거됨
- 세번째 반복 (`i === 2`)
	- `elems`에 남아있는 값은 두번째li요소 뿐임(Banana)
	- 이때 `elems.length`는 1이므로 for문의 조건식 `i < elems.length`가 false로 평가되어 반복이 종료됨

때문에 HTMLCollection객체를 for문으로 순회하면서 노드 객체의 상태를 변경할 땐 주의가 필요하다.

💡 해결방법 1: for문 역방향으로 순회
```js
<ul id="fruits">
    <li class="red">Apple</li>
    <li class="red">Banana</li>
    <li class="red">Kiwi</li>
</ul>

const elems = document.getElementsByClassName('red');

for(let i= elems.length-1; i >= 0; i--){
  elems[i].className = 'blue';
}
```
- 뒤에서부터 바꾸면, 현제 인데긋가 바뀌어도 앞쪽 요소 순서엔 영향 없음
- 예: 마지막 요소 Kiwi를 바꾸면, 앞쪽 인텍스에 영향 없음
- 컬렉션의 재정렬이 발생해도, 이미 지난 요소들이라 안전

💡 해결방법 2: while문 사용
```js
<ul id="fruits">
    <li class="red">Apple</li>
    <li class="red">Banana</li>
    <li class="red">Kiwi</li>
</ul>

const elems = document.getElementsByClassName('red');

let i = 0;

while(elems.length > i){
  elems[i].className = 'blue';
}
```
- `elems`가 남아있지 않을 때 까지 작업을 반복하므로.

💡⭐️ 베스트 해결방법 : `HTMLCollection`을 배열로 변환하기
```js
const elems = document.getElementsByClassName('red');

//이것도 ok
[...elems].forEach((elem)=> elem.className = 'blue')

//이것도 ok
const copyElems = [...elems]
for(let i=0; i<copyElems.length; i++){
  copyElems[i].className = 'blue';
}
```
- `HTMLCollection`객체가 부작용을 발생시키기 때문에, 이를 배열로 변환하여 안전하게 사용.

---
### NodeList

HTMLCollection 객체의 부작용을 해결하기 위해
NodeList를 반환하는 `querySelectorAll`을 사용하는 방법도 있다.

- NodeList객체는 실시간으로 노드 객체의 상태를 반영하지 않는 non-live객체
- 과거의 정적 상태를 유지함
- 하지만 childNodes 프로퍼티가 반환하는 NodeList 객체는 HTMLCollection과 같이 실시간으로 노드 객체의 상태를 반영하는 live객체로 동작함
- forEach를 사용할 수 있음

forEach 사용 가능 예제:
```js
<ul id="fruits">
    <li class="red">Apple</li>
    <li class="red">Banana</li>
    <li class="red">Kiwi</li>
</ul>

<style>
  .red { color: red; }
  .blue { color: blue; }
</style>

//NodeList 객체는 NodeList.prototype.forEach 메서드를 상속받아 사용할 수 있음
const elems = document.querySelectorAll('.red');
elems.forEach((e)=> e.className='blue')
```


NodeList가 live객체인 경우 발생하는 문제:
```js

<ul id="fruits">
    <li class="red">Apple</li>
    <li class="red">Banana</li>
</ul>

const elems = document.getElementById('fruits');

// live NodeList 객체
const {childNodes} = elems;

//childNodes의 자식 노드는 공백 텍스트 노드를 포함해
//모두 5개
console.log(childNodes) //NodeList(5) [text, li.red, text, li.red, text]

for(let i=0; i<childNodes.length; i++){
  elems.removeChild(childNodes[i]);
}

console.log(childNodes); //NodeList(2) [li.red, li.red]
```

- removeChild가 호출될 때마다 NodeList객체인 childNodes가 실시간으로 변경됨
- 따라서 첫번째, 세번째, 다섯 번째 요소만 삭제 된다.


=> 안전하게 DOOM컬렉션을 사용하려면 `HTMLCollection`이나 `NodeList` 객체를 배열로 변환하여 사용하는 것이 좋다.

---

## 노드 탐색

![[스크린샷 2025-08-06 오전 10.23.46.png]]

`Node.prototype`이 제공하는 메서드, 프로퍼티
- `parentNode`
- `previousSibling`
- `firstChild`
- `childNodes`

`Element.prototype`이 제공하는 메서드, 프로퍼티
- `previousElementSibling`
- `nextElementSibling`
- `children`


노드 탐색 프로퍼티는 모두 접근자 프로퍼티이나, 
setter없이 getter만 존재하는 읽기 전용 접근자 프로퍼티이다.
