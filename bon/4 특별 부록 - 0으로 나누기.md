
```js

1/0 //Infinity
1%0 //NaN

```

## 💡 질문
수학에서는 숫자를 0으로 나누는 식은 성립하지 않는다. (에러)
그런데 왜 자바스크립트에서
몫을 구하는 연산자로 숫자를 0으로 나누면 Infinity가 나오고
나머지를 구하는 연산자로 숫자를 0으로 나누면 NaN이 나오는걸까?

---
## 🔍 왜 `1 / 0 === Infinity`?

자바스크립트에서는 IEEE 754 부동소수점 방식을 따르기 때문에  
`1 / 0` 같은 표현은 **오류를 내는 대신** `Infinity`를 반환.

### 의미는?

- 수학적으로 `1 ÷ x`는 `x`가 0에 가까워질수록 값이 커진다.
	- `1 ÷ x` 는 1에 x가 몇개 들어가냐는 질문과 같다.
	- 1에 1은 1개 들어가므로 `1 / 1 = 1`이다.
	- 그렇다면 1에 0.1은 몇개 들어가는가? 10개 들어간다.
- 그래서 JS는 `1 / 0`을 "무한히 커진다"고 보고 `Infinity`로 처리.
	- 즉 0을 0으로 처리하지 않고 0에 근사한 값으로 측정함
	- 예: 0.1, 0.01, 0.00001...
	- 그러면 몫은 무한대로 커질 수 있음
- 비슷하게 `-1 / 0`은 **`-Infinity`**

➡️ **즉, "정의는 안 되지만 방향은 있다"는 식의 관대한 처리**

---
## ❌ 왜 `1 % 0 === NaN`?

`%`는 **나머지 연산자**이고, 연산 정의는 이렇다:

```js
a % b = a - Math.floor(a / b) * b
```


그런데 `1 % 0`을 넣어보면:

```js
1 - Math.floor(1 / 0) * 0
```


- `1 / 0`은 `Infinity`지만,
- `Math.floor(Infinity)`는 여전히 `Infinity`
- 그다음에 `Infinity * 0`은 **NaN** (수학적으로 정의 안됨)

➡️ 결과적으로 전체 수식이 **NaN (Not a Number)**이 되어버림.

---
