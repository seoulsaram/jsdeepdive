
## 이터레이션 프로토콜

##### 👉 이터레이션 프로토콜이란:

- <span style="background:#b1ffff">이터레이션</span>(Iteration)의 영어 원뜻 => <span style="background:#b1ffff">되풀이, 반복, 순회</span>
- 자바스크립트에서 "<u>순회 가능한</u>" 자료구조를 만드는데 사용되는 공식적인 규약이다.
- ES6 ECMAScript 사양에서부터 정의되었다.

##### 🔵 이터레이션 프로토콜을 구성하는 2가지 프로토콜

- 이터러블 프로토콜, 이터레이터 프로토콜로 구성 됨
- <span style="background:#fff88f">이터러블</span>의 영어 원뜻 => <span style="background:#fff88f">반복 가능한</span>
- <span style="background:#d3f8b6">이터레이터</span> 영어 원뜻 => <span style="background:#d3f8b6">반복하는 자, 순회자</span>

##### 이터러블 프로토콜
- 객체가 for..of 등에서 반복될 수 있게 해주는 약속
- 그 약속 내용 :
	- 객체에 `Symbol.iterator` 메서드가 구현되어 있거나 상속되어 있을 것.
	- 이 메서드는 "반복을 시작할 때" 실행됨
- 이터러블 프로토콜을 준수한 객체는 for..of 등으로 순회가 가능함


##### 이터레이터 프로토콜
- 실제로 값을 하나씩 꺼내주는 방법(=프로토콜).
- 이터러블에서 `Symbol.iterator`를 호출하면 `next`메서드를 가진 이터레이터(반복자)가 리턴됨.
- 이터레이터의 `next()`를 부를 때마다
	- `{value: 현재값, done: 끝났는지여부}` 이런 결과를 반환.
	- 이 값을 이터레이터 리절트 객체라고 함
- 이터레이터는 나복의 진행상황(포인터)을 기억해서 다음 값을 하나씩 반환하는 역할을 함.



👉 이터러블, 이터레이터 초간단 예시

```js
//이터러블 만들기
const iterable = {
  ...여러 오브젝트 내용,
  [Symbol.iterator](){
    return {
      next(){
        return {value:any, done:boolean}
      }
    }
  }
}

//이터레이터 낳기(응애)
const iterator = iterator[Symbol.iterator](); 

//이터레이터 사용하기
iterator.next();  // {value:??, done:??}
```

---
##### 💡 틈새 팁 : `for...in` 과 `for...of` 구분하기

```js

// ⭐️ for...in : in은 index의 in으로 오브젝트의 키를 꺼내는 함수
// (for...in을 배열에 사용하면 배열의 인덱스가 꺼내짐)

const arr = ['사과','배'];

for(const item in arr){
  console.log(item); // 0 1
}

// ⭐️ for...of : of는 배열의 값(value of array)를 하나씩 꺼내는 함수
for(const item of arr){
  console.log(item); // 사과 배
}
```

---

### ES6 이전에는 어땠나

ES6 이전에 순회 가능한 데이터 컬렉션 :
- 배열
- 문자열
- 유사 배열 객체
- DOM 컬렉션

이 데이터 컬렉션들은 통일된 규약 없이 각자 나름의 구조를 가지고
for문, for...in문, forEach 메서드 등 다양한 방법으로 순회할 수 있었다.

ES6에서는 순회 가능한 데이터 컬렉션을 
이터레이션 프로토콜을 준수하는 이터러블로 통일하여
for...of문, 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용할 수 있도록
일원화 했다.


---

## 이터러블

객체에 `Symbol.iterator` 메서드가 구현되어 있거나 상속되어 있어야 이터러블이다.
자바스크립트의 빌트인 이터러블 객체는 아래와 같다.

| Array      | `Array. prototype[Symbol.iterator]`                                                  |
| ---------- | ------------------------------------------------------------------------------------ |
| String     | `String.prototype[Symbol.iterator]`                                                  |
| Map        | `Map. prototype [Symbol.iterator]`                                                   |
| Set        | `Set. prototype [Symbol.iterator]`                                                   |
| TypedArray | `TypedArray.prototype [Symbol.iterator]`                                             |
| arguments  | `arguments [Symbol. iterator]`                                                       |
| DOM 컬렉션    | `NodeList.prototype[Symbol.iterator]`<br>`HTMLCollection.prototype[Symbol.iterator]` |

그렇기 때문에 위의 빌트인 이터러블 객체는
우리가 직접 `Symbol.iterator`를 구현할 필요가 없음.

```js
const array = [1, 2, 3];
console.log(Symbol.iterator in array); //true

console.log(Symbol.iterator new Map()); //true

console.log(Symbol.iterator in new Set()); //true
```


`Symbol.iterator` 메서드를 직접 구현하지 않거나
상속받지 않은 일반 객체는 이터러블이 아니다.

```js
const obj = {a:1, b:2}

console.log(Symbol.iterator in obj); //false

for(const item of obj){ // TypeError: obj is not iterable
  console.log(item)
}
```

하지만 스프레드 프로퍼티 제안 (`{...obj}`)은 
ES9에서 표준이 되었기 때문에 오브젝트도 스프레드 문법을 사용할 수 있다.

```js
console.log({...obj}); // {a: 1, b: 2}
```

---

## 이터레이터

이터러블의 `Symbol.iterator`를 호출하면 
`next`메서드를 가진 이터레이터(반복자)가 리턴됨.

```js
const array = [1,2,3];

// Symbol.iterator메서드는 이터레이터를 반환한다.
const iterator = array[Symbol.iterator]();

// 이터레이터는 next 메서드를 갖는다.
console.log('next' in iterator); //true
```

이터레이터의 `next`메서드는 
이터러블의 각 요소를 순회하기 위한
포인터의 역할을 한다.

즉, `next` 메서드를 호출하면 
이터러블을 순차적으로 한 단계씩 순회하며
순회 결과를 나타내는 이터레이터 리절트 객체를 반환한다.

```js
const array = [1,2,3];

const iterator = array[Symbol.iterator]();

console.log(iterator.next()); // {value: 1, done: false}
console.log(iterator.next()); // {value: 2, done: false}
console.log(iterator.next()); // {value: 3, done: false}
console.log(iterator.next()); // {value: undefined, done: true}
```

이터레이터의 `next` 메서드가 반환하는 
이터레이터 리절트 객체의 value 프로퍼티는
현재 순회 중인 이터러블의 값을 나타내며 
done 프로퍼티는 이터러블의 순회 완료 여부를 나타낸다.

---

## `for ... of` 문

`for...of` 문은 내부적으로 
이터레이터의 `next`메서드를 호출하여 이터러블을 순회한다.

- `iterator.next()`호출 => `{value: ??, done: boolean}` 이 반환됨
- 반환된 `value`를 변수(`item`)에 할당함
- 반환된 `done`이 `false`면 순회를 계속함
- 반환된 `done`이 `true`면 순회를 중단함

```js
for (const item of [1, 2, 3]){
	// item변수에 순차적으로 1,2,3이 할당된다.
	...
}
```


👉 `for...of`문의 내부 동작을 `for`문으로 표현한 것
```js

const iterable = [1, 2, 3]
const iterator = iterable[Symbol.iterator]();

// 초기화; 조건; 증감 을 생략한 무한 반복문
for(;;){
  const res = iterator.next();
  
  if(res.done) break;
  
  const item = res.value;
  console.log(item); //1 2 3
}

```

---

## 이터러블과 유사 배열 객체

유사 배열 객체의 특징:
- 배열처럼 인텍스로 프로퍼티 값에 접근할 수 있다.
- `length` 프로퍼티를 갖는다.
- `for`문으로 순회할 수 있다.
- 인덱스를 나타내는 숫자 형식의 문자열을 프로퍼티 키로 가진다.
- 때문에 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있다.
	- `arrayLike[1]`
- 하지만 `Array.prototype`을 상속받지 않아 `filter`, `forEach`등 배열의 프로퍼티/메서드를 사용할 수 없다.

```js
const arrayLike = {
	0: 1,
	1: 2,
	2: 3,
	length: 3
}

for(let i = 0; i < arrayLike.length; i++){
  console.log(arrayLike[i]); //1 2 3
}

```


🚨 하지만 유사 배열 객체는 일반 객체이며
위 표에서 본 것과 같이 `Symbol.iterator`를 상속받지 않는다.
즉 `Symbol.iterator`메서드가 없기 때문에 `for..of`문으로 순회할 수 없다.
```js
for(const item of arrayLike){ // Typeerror: arrayLike is not iterable
  console.log(item)
}
```

🚨 단 `arguments`, `NodeList`, `HTMLCollection`은 유사 배열 객체이면서 이터러블이다.
ES6에서 이터러블이 도입되면서 
유사 배열 객체인 위 객체들에 `Symbol.iterator`메서드를 구현하여 이터러블이 되었다. 
때문에 유사 배열 객체이면서 이터러블인 것이다. 
(배열이 아닌 이유는 Array.prototype을 상속받지 않으니까)

```js
// 유사 배열 객체이면서 이터러블로 만들기
const iterable = {
  0: "a", 1: "b", 2: "c", length: 3,
  [Symbol.iterator]: Array.prototype[Symbol.iterator]
};
for (const v of iterable) {
  console.log(v); // a, b, c
}
```

`Array.from`메서드를 사용하면 간단히 배열로 변환할 수 있다.
`Array.from`은 유사 배열 객체 또는 이터러블을 인수로 전달받아 배열로 변환하여 반환한다.
```js

const arrayLike = {
	0: 1,
	1: 2,
	2: 3,
	length: 3
}

const arr = Array.from(arrayLike);

console.log(arr); // [1, 2, 3]
```

---

### 데이터 공급자와 데이터 사용자

##### 데이터 공급자
- 데이터를 만들거나, 저장하거나, 내보내는 역할
- 데이터를 가지고 있고, "이걸 어떻게 쓸래?" 라고 사용자에게 넘겨줌

##### 데이터 사용자
- 공급자가 제공하는 데이터를 받아서 실제로 이용하는 쪽
	- 처리,변환,표시,저장 등
- 데이터를 소비하는 주체


##### 프로그래밍에서의 예시

배열 + for문
```js
const arr = [1,2,3];   // 공급자: arr (배열)
for(const v of arr) {   // 사용자: for문 (값을 소비)
  console.log(v);
}
```

함수형 프로그래밍
```js
function getData() {
  return [10, 20, 30];   // 공급자
}
const data = getData();
data.forEach(x => console.log(x)); // 사용자
```

이터러블/이터레이터
```js
const iterable = {
  [Symbol.iterator]() { ... } // 공급자 역할
}
for(const v of iterable) {    // 사용자
  // v를 실제로 이용
}
```





---
## 이터레이션 프로토콜의 필요성

##### 👉 ES6이전의 문제점
ES6이전에서는 순회 가능한 데이터 컬렉션,
즉 배열, 문자열, 유사 배열 객체, DOM 컬렉션 등은
통일된 규약 없이 각자 나름의 구조를 가지고 
for문, for...in문, forEach메서드 등
다양한 방법으로 순회할 수 있었다.

##### 👉 ES6에서 순회 가능한 자료구조 프로토콜을 정의
ES6에서는 순회 가능한 데이터 컬렉션을
이터레이션 프로토콜을 준수하는 이터러블로 통일하여
for...of문, 스프레드문법, 배열 디스트럭처링 할당의 대상으로 사용할 수 있도록
일원화했다.

##### 👉 이터러블은 데이터 공급자다
이터러블은 for...of문, 스프레드 문법, 배열 디스트럭처링 할당과 같은
데이터 소비자에 의해 사용되므로, 데이터 공급자의 역할을 한다고 할 수 있다.

만약 다양한 데이터 공급자가 각자의 순회 방식을 갖는다면
데이터 소비자는 다양한 데이터 공급자의 순회 방식을 모두 지원해야 한다.

하지만 다양한 데이터 공급자가 이터레이션 프로토콜을 준수하도록 규정하면
데이터 소비자는 이터레이션 프로토콜만 지원하도록 구현하면 된다.


##### 예시 (ES6 이전)
```js
// 배열
var arr = [10, 20, 30];
for (var i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}

// 문자열
var str = "ABC";
for (var i = 0; i < str.length; i++) {
  console.log(str[i]);
}

// 유사 배열 객체
var arrayLike = { 0: 'x', 1: 'y', 2: 'z', length: 3 };
for (var i = 0; i < arrayLike.length; i++) {
  console.log(arrayLike[i]);
}

// DOM 컬렉션 (NodeList)
var nodeList = document.querySelectorAll('div');
for (var i = 0; i < nodeList.length; i++) {
  console.log(nodeList[i]);
}
```

- 위의 모든 예제에서 for문을 사용하여 순회 가능
- 즉 인덱스와 length 프로퍼티만 있으면 순회가 가능함.
- 하지만 한계가 존재:
	- forEach나 map같은 고차 함수는 배열만 쓸 수 있었음
	- 문자열, 유사 배열 객체, DOM 컬렉션 등은 순회 가능한 별도의 메서드가 없었음
	- for...in은 객체의 프로퍼티를 순회하기 때문에 배열에는 권장되지 않았음

##### 👉 ES6 이후에는
- 이터레이션 프로토콜을 도입하면서 "진짜 순회 가능한 것"과 "인덱스 기반 순회만 가능한 것"이 구분되기 시작함
- 이제 for...of같은 구문에서는 반드시 이터러블만 순회 가능
- 유사 배열 객체는 Symbol.iterator가 없으므로 for...of에서 직접 쓸 수 없음


이처럼 이터레이션 프로토콜은 다양한 데이터 공급자가
하나의 순회 방식을 갖도록 규정하여
데이터 소비자가 효율적으로 다양한 공급자를 사용할 수 있도록
데이터 소비자와 데이터 공급자를 연결하는 인터페이스의 역할을 한다.

![[스크린샷 2025-07-09 오전 10.05.58.png]]

---

## 사용자 정의 이터러블

이터레이션 프로토콜을 준수하지 않는 일반 객체도
이터레이션 프로토콜을 준수하도록 구현하면
사용자 정의 이터러블이 된다.

```js
//피보나치 수열을 구현한 사용자 정의 이터러블
const fibonacci = {
  [Symbol.iterator](){
    let [pre, cur] = [0, 1]; 
    const max = 10; // 수열의 최대값
    
    
    return {
      next(){
        [pre, cur] = [cur, pre + cur];
        return {value: cur, done: cur >= max};
      }
    }
  }
}

//for...of순회 가능
for(const num of fibonacci){
  console.log(num);
}

//스프레드문법 가능
const copy = [...fibonacci];
console.log(copy) //[1, 2, 3, 5, 8]

//배열 디스트럭처링 가능
const [first, second] = fibonacci; 
console.log(first, second); //1 2

//퀴즈
console.log(fibonacci[0]) // ?
const iterable = fibonacci; //리턴된건 무엇?
```

### 📚 중간 퀴즈 - 위 예제를 max를 인자로 받는 걸로 바꾸기

답) 
```js
const fibonacci = function (max){
  let [pre, cur] = [0,1];
  return {
    [Symbol.iterator](){
      return {
        next(){
          [pre, cur] = [cur, pre + cur];
          return {value:cur, done:cur >= max}
        }
      }
    }
  }
}

for(const num of fibonacci(10)){
  console.log(num);
}
```


---
#### 이터러블이면서 이터레이터인 객체를 생성하는 함수

앞의 fibonacci함수는 이터러블을 반환한다.
만약 이터레이터를 생성하려면 이터러블의 `Symbol.iterator`메서드를 호출해야 한다.

```js
const iterable = fibonacci(5);
const iterator = iterable[Symbol.iterator]();

console.log(iterator.next()); // {value: 1, done: false}
```


하지만 둘 다 되는 경우(이터러블이면서 이터레이터)로 만들면
`Symbol.iterator` 메서드를 호출하지 않아도 된다.

- 이터러블 : `Symbol.iterator` 메서드가 구현되어 있고, 이 메서드가 이터레이터를 반환하는 객체
- 이터레이터 : `next()` 메서드가 있고, 이 메서드가 `{value, done}` 형태의 이터레이션 리절트 객체를 반환함

=> 어떤 객체가 **Symbol.iterator**와 **next** 둘 다 직접 가지고 있다면  
"나는 직접 나 자신이 이터레이터야!" 라는 의미

이렇게 만들면 코드도 짧고 좋음.
```js
const myIterableIterator = {
  current: 1,
  last: 5,
  // Symbol.iterator 메서드: 자기 자신을 반환!
  [Symbol.iterator]() {
    return this;
  },
  // next 메서드: 이터레이션 리절트 반환
  next() {
    if (this.current <= this.last) {
      return { value: this.current++, done: false };
    } else {
      return { value: undefined, done: true };
    }
  }
};
```

앞의 fibonacci함수를 이터러블이면서 이터레이터인 객체를 생성하여 반환하는 함수로 변경해보자.
```js
const fibonacci = function (max){
  let [pre, cur] = [0,1];
  
  return {
    [Symbol.iterator](){return this;},
    next(){
      [pre, cur] = [cur, pre + cur];
      return {value: cur, done:cur >= max}
    }
  }
}

let iter = fibonacci(10);

for(const num of iter){
  console.log(num);
}

iter = fibonacci(10);

console.log(iter.next());
console.log(iter.next());
```


---
#### 무한 이터러블과 지연 평가

```js
const fibonacciInfinit = function (){
  let [pre, cur] = [0,1];
  
  return {
    [Symbol.iterator](){return this;},
    next(){
      [pre, cur] = [cur, pre + cur];
      // 무한을 구현해야 하므로 done 프로퍼티를 생략함.
      return {value: cur}
    }
  }
}

for(const num of fibonacciInfinit()){
  if(num > 1000) break;
  console.log(num);
}

const [f1, f2, f3] = fibonacciInfinit();
console.log(f1, f2, f3);
```

지연 평가는 데이터가 필요한 시점 이전까지는 미리 데이터를 생성하지 않다가
데이터가 필요한 시점이 되면 그때야 비로소 데이터를 생성하는 기법이다.
즉, 평가 결과가 필요할 때까지 평가를 늦추는 기법이 지연 평가다.


배열의 경우
- `[1, 2, 3, 4, 5]` 는
- 이 다섯 개의 값이 처음부터 메모리에 모두 들어가 있음
- 배열이 만들어질 때 이미 데이터가 다 준비 됨

fibonacciInfinit함수(지연평가)의 경우
- 아직 데이터가 메모리에 만들어진게 아님
- 누가 데이터를 달라고(next()호출)하기 전까진, 아무것도 만들어져 있지 않음
- 데이터를 요청할 때마다 그때그때 필요한 값만 계산해서 하나씩 줌

예시1) `for...of` 순회
```js
for(const num of fibonacciInfinit()){
  if(num > 1000) break;
  console.log(num);
}
```

- 이 코드는 피보나치 수열을 끝없이 만들어낼 수 있지만, 1000이 넘으면 멈춤
- `for...of`문이 반복될 때마다 내부적으로 
	- `next()`가 불림 -> 피보나치 값을 즉석에서 계산해서 줌
- 미리 1000까지 모든 피보나치 값을 만들어놓지 않음
- 필요한 값이 필요할 때마다, 바로 그 순간에 만들어서 내보냄(이게 지연 평가)


예시2) 배열 디스트럭처링 할당
```js
const [f1, f2, f3] = fibonacciInfinit();
console.log(f1, f2, f3);
```

- 피보나치 이터러블에서 값 3개만 달라
- 자바스크립트가 내부적으로 `next()`를 3번만 호출해서 각각의 값을 그때그때 만들어 할당해줌
- 이 경우에도 딱 3개만 만듦


만약 피보나치 수열을 "배열"로 만들어서 미리 다 저장한다면?
- 무한하니까 배열이 끝도 없이 커짐
- 메모리 터짐

하지만 이터러블(이터레이터)로 만들면
- 값이 필요할 때마다, 딱 그 순간에 하나씩 만들어서 주고,
- 원하면 멈출 수 있음(break 등으로)
- 무한한 데이터도 표현할 수 있음 (이건 지연 평가의 장점이기도 함)

---

### 📚 퀴즈

##### 이터러블은 배열인가?
Yes / No
<details>
<summary>답</summary>
No. 배열은 이터러블의 한 종류이나, Symbol.iterator를 구현하는 모든 객체가 이터러블임
</details>

##### 배열은 이터러블의 한 종류인가?
Yes / No
<details>
<summary>답</summary>
Yes. `Array. prototype[Symbol.iterator]` 를 상속받음.
</details>

##### 이터러블은 유사배열 객체인가?
Yes / No
<details>
<summary>답</summary>
No. 유사 배열 객체는 배열처럼 보이지만 이터러블이 아닐 수 있다. 이터러블이려면 Symbol.iterator가 필요
</details>

##### 이터러블이면서 이터레이터인 객체를 자유롭게 하나 만들어보기